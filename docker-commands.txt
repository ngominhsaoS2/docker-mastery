8. Docker Editions: Which Do I Use?
Docker CE (Comunity Editions) and Docker EE (Enterprise Editions)
Three major types of install: Direct, Mac/Win, Cloud
Docker for Windows, Docker for Mac and Docker for AWS/Azure/Google


12. Docker for Mac Setup and Tips
Download and install Docker Desktop for Mac
Intall docker extension on VS Code
Install bash-completion via these instructions:
   - https://docs.docker.com/compose/completion/
   - https://docs.docker.com/docker-for-mac/#install-shell-completion
   - then open another terminal to use it


18. Check Our Docker Install and Config
docker version :check your versions and that docker is working

eg:
saonms-macpro:docker-mastery saonm$ docker version
Client: Docker Engine - Community
 Cloud integration: 1.0.2
 Version:           19.03.13
 API version:       1.40
 Go version:        go1.13.15
 Git commit:        4484c46d9d
 Built:             Wed Sep 16 16:58:31 2020
 OS/Arch:           darwin/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.13
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       4484c46d9d
  Built:            Wed Sep 16 17:07:04 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          v1.3.7
  GitCommit:        8fba4e9a7d01810a393d5d25a3621dc101981175
 runc:
  Version:          1.0.0-rc10
  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683


docker info :shows most configuration values for the enging


19. Starting a Nginx Web Server
Image is biraries, libraries, source code ... we want to run
Container is a running instance of an Image
We can have many Containers running based on one Image

docker container run --publish 8888:80 nginx :will do below things:
   - find the Image locally, if does not find, then downloads Image 'nginx' (latest version) from Docker Hub
   - starts a new Container form this Image
   - Opens port 80 on the host IP, --publish (in this case, my mac, my physical mac)
   - routes traffic to the container IP, port 8888
   - then we open browser and go to localhost:8888, it will go to nginx home page

ctrl + C :to stop the container
docker container ls :list all running containers (docker ps)
docker container ls -a :list all containers
docker container stop <container id> :to stop a running container
docker container run always starts a NEW container
docker container start to start an existing stopped container

docker container run --publish 8888:80 --detach --name <container name> nginx :to detach the random name, and name the new container
docker container logs <container name or id> :view container logs
docker container top <container name or id> :list processes of the running container
docker container rm <list container IDs> :remove containers


24. Assignment Answers: Manage Multiple Containers
docker container run -d -p 3307:3306 --name db -e MYSQL_RANDOM_ROOT_PASSWORD=yes mysql (cuz port 3306 is already used by local mysql app)
docker container run -d --name webserver -p 8080:80 httpd
docker container run -d --name proxy -p 8888:80 nginx (cuz port 80 is already used by local nginx process)

Here is steps to check:
   - curl localhost:8888 (to test nginx)
   - curl localhost:8080 (to test apache/httpd)

docker image ls :list all local Images
-d :it's the short version of --detach. By running in detached mode, we are able to have access to our command line when the container spins up and runs. Without it, we would have logs constantly fed onto the screen.
You didn't specify the -d flag to detach it in the background, and there aren't any logs coming across the screen because you haven't connected to the published port yet, so Nginx has nothing to log about.


25. What's Going On In Containers: CLI Process Monitoring
docker container top :list processes in one Container
docker container inspect :details of one Container configuration
docker container stats :performance stats for all Container


26. Getting a Shell Inside Containers: No Need for SSH
docker container run -it --name proxy nginx bash :to open a terminal after running a new 'nginx' Container
   1/ -t :short for --tty, pseudo-tty, simulates a real terminal, like what SSH does
   2/ -i :short for --interactive, keep session open to receive terminal input
   3/ bash :if run with -it, it will give you a terminal inside the running Container

docker container run -it --name ubuntu ubuntu :run a 'ubuntu' Image, then open a terminal on it (ubuntu Image default CMD is bash, so we dont have specify it)
docker container start -ai ubuntu :start ubuntu container, then open a terminal
docker container exec -it mysql bash :on 'mysql' running container, open a terminal (run additional command in existing Container)
docker pull <image name> :pull an Image from Docker Hub


27. Docker Networks: Concepts for Private and Public Comms in Containers
Each container connected to a private virtual network "bridge"
Each virtual network routes through NAT firewall on host IP
All containers on a virtual network can talk to each other with -p
Best practice is to create a new virtual network for each app:
   - network "my_web_app" for mysql and php/apache Containers
   - network "my_api" for mongo and nodejs Containers

docker container port <container name of id> :display port config of the running container
docker container inspect --format '{{ .NetworkSettings.IPAddress }}' <container name of id> :display the container id on the current virtual network


29. Docker Networks: CLI Management of Virtual Networks
docker network ls :list all current virtual networks
eg:
saonms-macpro:~ saonm$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
6f922a79eb52        bridge              bridge              local
10ec83292d8f        host                host                local
3eaffcd000b5        none                null                local

--network bridge :default docker virtual network, which is NAT'ed behind the Host IP
--network host :it gains performance by skipping virtual networks but sacrifices security of container model
--network none :removes eth0 and only leaves you with localhost interface in container


docker network inspect <network name of id>
eg:
saonms-macpro:~ saonm$ docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "6f922a79eb520ebd78b7cadbe3cbbd1659c2fc98af80b019adc5f04803976a9b",
        "Created": "2020-11-12T16:15:17.011363034Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": { //saonm: ipconfig. It can be changed.
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": { //saonm: shows all containers connect to this network (container Id, container Name, IPv4, IPv6...)
            "4adbb9a5a0a1b1ddba70177e5337f18fccdc863ac2b04d56099256083c5f39df": {
                "Name": "webhost",
                "EndpointID": "54e37b1b824f1b739237135541db9b6a52e4ebc5386ea454820030e012e711e5",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]


docker network create <name> :create a new virtual network
network driver :built-in or 3rd party extensions that give you virtual network features
docker container run -d --name <container-name> --network <network-name> <image-name>
   --network to specify a virtual network for this container
docker network inspect <network-name> :check containers property to see the above container is attached to this network
docker network connect <network-name> <existing-container> :connect a Container to a Network
docker network disconnect <network-name> <existing-container> :disconnect a Container from a Network
docker container inspect <container-id-name> :then check the Networks property to see all virtual network that the container connects to


30. Docker Networks: DNS and How Containers Find Each Other
docker DNS :docker daemon has a built-in DNS server that containers use by default
docker container exect -it <container-first> ping <container-second> :to test connect from first container to second container (in this case, they are in the same virtual network)

Docker Networks: DNS
Containers should not rely on IP's for inter-communication
DNS for friendly names is built-in if you use custom networks
You're using custom networks right?
This gets way easier with Docker Compose in future section

























